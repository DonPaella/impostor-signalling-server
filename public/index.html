<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IMPOSTOR Game</title>
  <style>
    :root{ --bg:#0f1720; --card:#0b1220; --muted:#9aa4b2; --accent:#7c3aed; }
    body { font-family: Inter, 'Segoe UI', system-ui, -apple-system, sans-serif; text-align: center; background: linear-gradient(180deg,#071024 0%, #0f1720 100%); color: #e6eef6; padding: 2em; }
    .card{ background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.04); padding: 1rem 1.2rem; border-radius: 12px; display: inline-block; text-align:left; min-width:320px; }
    input, button { padding: 0.55em 1em; margin: 0.4em; font-size: 1em; border-radius: 8px; border: none; }
    input{ background: rgba(255,255,255,0.03); color: inherit; border: 1px solid rgba(255,255,255,0.04); }
    button { background: linear-gradient(90deg,var(--accent),#3b82f6); color: #fff; cursor: pointer; box-shadow: 0 6px 18px rgba(124,58,237,0.12); border-radius:8px; }
    button.secondary{ background: #222; box-shadow:none; }
    button:active{ transform: translateY(1px); }
    .hidden { display: none; }
    .fade { transition: opacity 0.35s ease-in-out; }
    #playerList p { margin: 0.2em 0; }
    #voteButtons button { display: inline-block; margin: 0.3em; }
    #leaderboard p { margin: 0.2em 0; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    /* spinner wheel */
    .wheel{ width:220px; height:220px; border-radius:50%; position:relative; margin:0.6rem auto; transform: rotate(0deg); }
    .wheel.spinning{ animation: spin 1s linear infinite; }
    .wheel .label{ position:absolute; left:50%; top:50%; transform-origin: center -70px; font-size:0.9rem; color: #051; color: #e6eef6; }
    .spinner-pointer{ width:0;height:0;border-left:12px solid transparent;border-right:12px solid transparent;border-bottom:18px solid var(--accent); margin:0 auto 0.6rem; }
    .small-muted{ color:var(--muted); font-size:0.85rem; }
  </style>
</head>
<body>
  <h1>üé≠ IMPOSTOR Game</h1>

  <div id="menu">
    <button onclick="hostGame()">Host Game</button>
    <button onclick="joinGame()">Join Game</button>
  </div>

  <div id="setup" class="hidden card">
    <p id="gameCodeDisplay"></p>
    <input id="playerName" placeholder="Your name" />
    <button onclick="submitPlayer()">Join</button>
    <div id="playerList"></div>
    <div style="margin-top:0.5rem"><label class="small-muted">HOW MANY ROUNDS</label><br/>
    <input id="roundsInput" type="number" value="3" min="1" style="width:6rem" />
    </div>
    <button onclick="startGame()">Start Game</button>
  </div>

  <div id="game" class="hidden">
    <h2 id="roleText"></h2>
    <div id="hintPhase" class="hidden">
      <p id="currentPlayer"></p>
      <input id="hintInput" placeholder="Enter your hint" />
      <button onclick="submitHint()">Submit Hint</button>
      <p id="timerDisplay"></p>
    </div>
    <div id="requestVote" class="hidden">
      <button onclick="requestEndVote()">Request End & Vote</button>
      <p id="voteStatus"></p>
    </div>

    <div id="traitorGuessSection" class="hidden">
      <h3>Traitor: Guess the secret word</h3>
      <input id="traitorGuess" placeholder="Enter your guess" />
      <button onclick="submitTraitorGuess()">Submit Guess</button>
    </div>
    <div id="votePhase" class="hidden">
      <h3>Vote for the IMPOSTOR</h3>
      <div id="voteButtons"></div>
    </div>
    <div id="spinnerPhase" class="hidden card">
      <h3 style="margin-top:0">üåÄ Tie! Spinning...</h3>
      <div class="spinner-pointer"></div>
      <div id="spinnerWheel" class="wheel"></div>
      <p id="spinnerResult" class="small-muted"></p>
    </div>
    <div id="revealPhase" class="hidden">
      <h2 id="revealText"></h2>
      <button onclick="nextRound()">Next Round</button>
    </div>
    <div id="endGame" class="hidden">
      <h2>üèÜ Final Leaderboard</h2>
      <div id="leaderboard"></div>
    </div>
  </div>

  <script>
    // WebSocket-based multiplayer client
    const socket = new WebSocket((location.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + location.host);

    let myId = null;
    let room = null;
    let isHost = false;
    let players = []; // {id,name,score}
    let order = [];
    let turnIndex = 0;
    let hintRound = 1;
    let totalRounds = 3;

    socket.addEventListener('open', () => { console.log('ws open'); });
    socket.addEventListener('message', (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch (e) { return; }
      handleMessage(msg);
    });

    function send(msg) { socket.send(JSON.stringify(msg)); }

    function hostGame() { isHost = true; document.getElementById('menu').classList.add('hidden'); document.getElementById('setup').classList.remove('hidden'); document.getElementById('gameCodeDisplay').textContent = 'Hosting...'; }

    function joinGame() { isHost = false; const code = prompt('Enter game code:'); if (!code) return; room = code; document.getElementById('menu').classList.add('hidden'); document.getElementById('setup').classList.remove('hidden'); document.getElementById('gameCodeDisplay').textContent = 'Game Code: ' + room; }

    function submitPlayer() {
      const name = document.getElementById('playerName').value.trim(); if (!name) return alert('Enter a name');
      document.getElementById('playerName').value = '';
      if (isHost) {
        send({ type: 'create-room', payload: { name } });
      } else {
        if (!room) return alert('No game code');
        send({ type: 'join-room', room, payload: { name } });
      }
    }

    function startGame() {
      if (!isHost) return;
      totalRounds = parseInt(document.getElementById('roundsInput').value) || 3;
      send({ type: 'start-game', room, payload: { rounds: totalRounds } });
    }

    function submitHint() {
      const text = document.getElementById('hintInput').value.trim(); if (!text) return; send({ type: 'submit-hint', room, payload: { text } });
      document.getElementById('hintInput').value = '';
      // advance local turn
      advanceTurn();
    }

    function advanceTurn() {
      turnIndex++;
      if (turnIndex >= order.length) { turnIndex = 0; hintRound++; if (hintRound > 2) { document.getElementById('hintPhase').classList.add('hidden'); document.getElementById('requestVote').classList.remove('hidden'); } }
      renderTurn();
    }

    function requestEndVote() { send({ type: 'request-end-vote', room }); }

    function castVote(targetId) {
      // show confirm
      const ok = confirm('Submit vote for ' + (players.find(p=>p.id===targetId)||{}).name + '?'); if (!ok) return; send({ type: 'cast-vote', room, payload: { targetId } });
      document.getElementById('votePhase').classList.add('hidden');
    }

    function submitTraitorGuess() {
      const g = document.getElementById('traitorGuess').value.trim(); if (!g) return; send({ type: 'traitor-guess', room, payload: { guess: g } }); document.getElementById('traitorGuess').value = ''; document.getElementById('traitorGuessSection').classList.add('hidden');
    }

    function handleMessage(msg) {
      const t = msg.type;
      if (t === 'room-created') { room = msg.room; document.getElementById('gameCodeDisplay').textContent = 'Game Code: ' + room; }
      else if (t === 'joined') { myId = msg.id; room = msg.room; document.getElementById('gameCodeDisplay').textContent = 'Game Code: ' + room; }
      else if (t === 'player-list') { players = msg.players; window.hostId = msg.hostId; renderPlayerList(); }
      else if (t === 'player-joined') { /* no-op; player-list will refresh when server sends player-list */ }
      else if (t === 'game-started') {
        order = msg.order; turnIndex = 0; hintRound = 1; document.getElementById('setup').classList.add('hidden'); document.getElementById('game').classList.remove('hidden'); document.getElementById('hintPhase').classList.remove('hidden'); document.getElementById('requestVote').classList.add('hidden'); renderTurn(); document.getElementById('votePhase').classList.add('hidden'); document.getElementById('spinnerPhase').classList.add('hidden'); document.getElementById('revealPhase').classList.add('hidden');
      }
      else if (t === 'role') {
        if (msg.role === 'IMPOSTOR') { document.getElementById('roleText').textContent = 'You are the IMPOSTOR'; }
        else { document.getElementById('roleText').textContent = 'You are FAITHFUL (secret: ' + msg.secret + ')'; }
      }
      else if (t === 'hint') {
        const el = document.getElementById('playerList'); const p = document.createElement('p'); p.textContent = `${msg.from}: ${msg.text}`; el.appendChild(p);
      }
      else if (t === 'turn-start') {
        // show who has the turn and start a countdown
        const cur = msg.playerId; const curPlayer = players.find(p=>p.id===cur);
        document.getElementById('currentPlayer').textContent = `It's ${curPlayer ? curPlayer.name : '...?'}'s turn (Pass ${msg.hintPass}/2)`;
        startTurnTimer(msg.timeout || 20, cur === myId);
        // enable/disable input based on whether it's our turn
        const isMyTurn = (cur === myId);
        document.getElementById('hintInput').disabled = !isMyTurn; document.querySelector('#hintPhase button').disabled = !isMyTurn;
      }
      else if (t === 'your-turn') {
        // direct ping to enable controls (server authoritative)
        document.getElementById('hintInput').disabled = false; document.querySelector('#hintPhase button').disabled = false;
      }
      else if (t === 'turn-grace') {
        // show grace countdown
        startTurnTimer(msg.grace || 10, msg.playerId === myId, true);
      }
      else if (t === 'end-vote-status') {
        document.getElementById('voteStatus').textContent = `Requests: ${msg.count}/${msg.needed}`;
      }
      else if (t === 'hints-complete') {
        document.getElementById('hintPhase').classList.add('hidden'); document.getElementById('requestVote').classList.remove('hidden');
      }
      else if (t === 'start-vote') {
        document.getElementById('hintPhase').classList.add('hidden'); document.getElementById('requestVote').classList.add('hidden'); document.getElementById('votePhase').classList.remove('hidden'); renderVoteButtons(); startVoteTimer(msg.timeout || 20);
      }
      else if (t === 'vote-tie') {
        // build spinner for tied players
        window.voteTieTop = msg.top || [];
        buildSpinner(window.voteTieTop);
        document.getElementById('votePhase').classList.add('hidden'); document.getElementById('spinnerPhase').classList.remove('hidden');
        const wheel = document.getElementById('spinnerWheel'); wheel.classList.add('spinning'); document.getElementById('spinnerResult').textContent = 'Spinning...';
      }
      else if (t === 'vote-result') {
        // if there was a tie spinner, animate to the chosen
        const chosenId = msg.chosenId; const chosenName = msg.chosenName || '';
        if (window.voteTieTop && window.voteTieTop.length > 0) {
          // animate wheel to land on chosen
          const idx = window.voteTieTop.indexOf(chosenId);
          const wheel = document.getElementById('spinnerWheel');
          wheel.classList.remove('spinning');
          const n = window.voteTieTop.length;
          const anglePer = 360 / n;
          const target = 360*3 + (idx * anglePer) + anglePer/2;
          wheel.style.transition = 'transform 2s cubic-bezier(.2,.8,.2,1)';
          wheel.style.transform = `rotate(${target}deg)`;
          wheel.addEventListener('transitionend', function te(){
            document.getElementById('spinnerResult').textContent = `Chosen: ${chosenName}`;
            wheel.removeEventListener('transitionend', te);
            // clear vote tie state
            window.voteTieTop = null;
          });
        } else {
          document.getElementById('votePhase').classList.add('hidden'); document.getElementById('spinnerPhase').classList.remove('hidden'); document.getElementById('spinnerResult').textContent = `Chosen: ${chosenName || 'Unknown'}`;
        }
      }
      else if (t === 'ask-traitor-guess') {
        // show guess UI to this client
        document.getElementById('traitorGuessSection').classList.remove('hidden');
      }
      else if (t === 'player-kicked') {
        alert(`${msg.name} was removed: ${msg.reason}`);
        // server will send updated player-list
      }
      else if (t === 'round-end') {
        document.getElementById('spinnerPhase').classList.add('hidden'); document.getElementById('revealPhase').classList.remove('hidden');
        let txt = '';
        if (msg.result === 'traitor-guessed-correctly') txt = 'Traitor guessed correctly and wins this round!';
        else if (msg.result === 'faithfuls-win') txt = 'Faithfuls win this round!';
        else if (msg.result === 'impostor-survived') txt = 'Impostor survived and gets the point.';
        document.getElementById('revealText').textContent = txt + ' Secret word: ' + msg.secret;
        // update leaderboard display
        const lb = document.getElementById('leaderboard'); lb.innerHTML = ''; (msg.scores||[]).forEach(s=>{ const p = document.createElement('p'); p.textContent = s.name + ': ' + s.score; lb.appendChild(p); });
      }
      else if (t === 'game-end') {
        document.getElementById('game').classList.add('hidden'); document.getElementById('endGame').classList.remove('hidden'); const lb = document.getElementById('leaderboard'); lb.innerHTML = ''; (msg.leaderboard||[]).forEach(s=>{ const p = document.createElement('p'); p.textContent = s.name + ': ' + s.score; lb.appendChild(p); });
      }
    }

    // Turn timer handling on client
    let turnTimerInterval = null;
    function startTurnTimer(seconds, isMine, isGrace) {
      clearInterval(turnTimerInterval);
      let time = seconds;
      document.getElementById('timerDisplay').textContent = `‚è≥ ${time}s`;
      turnTimerInterval = setInterval(()=>{
        time--; document.getElementById('timerDisplay').textContent = `‚è≥ ${time}s`;
        if (time <= 0) { clearInterval(turnTimerInterval); if (isGrace && isMine) { alert('You were removed for timeout'); } }
      }, 1000);
    }

    function renderPlayerList() {
      const el = document.getElementById('playerList'); el.innerHTML = ''; players.forEach(p=>{ const pEl = document.createElement('p'); pEl.textContent = p.name + (p.score ? ' ('+p.score+')' : ''); el.appendChild(pEl); });
      // show start button only to host
      const startBtn = document.querySelector('button[onclick="startGame()"]');
      if (myId && window.hostId && myId === window.hostId) startBtn.style.display = 'inline-block'; else startBtn.style.display = 'none';
    }

    function renderTurn() {
      if (!order || order.length === 0) return; const curId = order[turnIndex]; const curPlayer = players.find(p=>p.id===curId);
      document.getElementById('currentPlayer').textContent = `It's ${curPlayer ? curPlayer.name : '...?'}'s turn (Round ${hintRound}/2)`;
      const isMyTurn = curId === myId;
      document.getElementById('hintInput').disabled = !isMyTurn; document.querySelector('#hintPhase button').disabled = !isMyTurn;
    }

    function renderVoteButtons() {
      const container = document.getElementById('voteButtons'); container.innerHTML = ''; players.forEach(p=>{ const btn = document.createElement('button'); btn.textContent = p.name; btn.onclick = () => castVote(p.id); container.appendChild(btn); });
    }

    function buildSpinner(topIds) {
      const wheel = document.getElementById('spinnerWheel'); wheel.innerHTML = '';
      if (!topIds || topIds.length === 0) return;
      const n = topIds.length;
      topIds.forEach((id, i) => {
        const p = players.find(x=>x.id===id) || { name: id };
        const label = document.createElement('div');
        label.className = 'label';
        const angle = (i * (360 / n));
        label.style.transform = `rotate(${angle}deg) translateY(-70px)`;
        label.textContent = p.name;
        wheel.appendChild(label);
      });
      // reset transform
      wheel.style.transition = '';
      wheel.style.transform = 'rotate(0deg)';
    }

    let voteTimerInterval = null;
    function startVoteTimer(seconds) {
      let time = seconds; document.getElementById('timerDisplay').textContent = `‚è≥ ${time}s`;
      clearInterval(voteTimerInterval);
      voteTimerInterval = setInterval(()=>{ time--; document.getElementById('timerDisplay').textContent = `‚è≥ ${time}s`; if (time<=0) clearInterval(voteTimerInterval); },1000);
    }
  </script>
</body>
</html>
